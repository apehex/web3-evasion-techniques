\section{Fake Standard Implementation} \label{sec:fake-implementation}

\subsection{Overview}

Such contracts borrows the function \& class names from industry standards(OpenZeppelin, ERC, etc), but the code inside is actually different.

The malicious contracts generally pretend to be:

\begin{description}
\item[proxies]{but the implementation is either not used or different from the ERC-1967 proxy}
\item[tokens]{but the transfer and / or approve functions behave differently than ERC-20 / 721 / 1155}
\end{description}

\subsection{Evasion Targets}

\begin{description}
\item[block explorers]{the interpretation of proxies is fixed, it can easily be fooled}
\item[users]{few users actually check the code, having a valid front is enough}
\end{description}

\subsection{Samples}

\subsubsection{Fake EIP-1967 Proxy}

Standard EIP-1967 \cite{eip-1967} has pointers located in specific storage slots:

\begin{description}
\item[0x360894a13ba...]{location of the logic contract address}
\item[0xa3f0ad74e54...]{location of the beacon contract address}
\end{description}

These can be kept null or point to any contract, while the proxy actually uses another address.

A minimal example was given at DEFI summit 2023 \cite{video-masquerading-code}:

\begin{lstlisting}[language=Solidity]
function _getImplementation() internal view returns (address) {
    return
        StorageSlot
            .getAddressSlot(bytes32(uint256(keccak256("eip1967.fake")) - 1)).
            .value;
}
\end{lstlisting}

Etherscan will show some irrelevant contract, giving the impression it is legit.

\pagebreak
\subsubsection{Fake ERC20 Token}

Many phishing operations deploy fake tokens with the same symbol and name as the popular ones.

For example, \href{https://etherscan.io/address/0x5ed7ca349efc40550eecef4b288158fb2b9f12de#code}{this contract} is spoofing the USDC token.
It was used in \href{https://explorer.phalcon.xyz/tx/eth/0x7448178a8a03a0f1f298b697507f0e9172eacf1d32d422f48d0345c19c76eba3?line=33}{this phishing transaction}.

\subsection{Detection \& Countermeasures}

Several sources can be monitored, depending on the standard that is being spoofed:

\begin{description}
\item[Storage]{comparing the target of \lstinline[language=Solidity]{delegateCall} to the address in the storage slots of the standards}
\item[Events]{changes to the address of the logic contract should come with an \lstinline[language=Solidity]{Upgraded} event}
\item[Bytecode]{the implementation of known selectors can be checked agains the standard's reference bytecode}
\end{description}
