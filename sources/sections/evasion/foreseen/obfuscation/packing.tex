\section{Payload Packing} \label{sec:packing}

\subsection{Overview}

For software executables, packing applies a combination of encryption / encoding / compression on a binary.
These operations are reversed during execution. Originally, the purpose was to spare secondary memory and make software more compact.

This motivation \href{https://medium.com/joyso/solidity-compress-input-in-smart-contract-d9a0eee30fe0}{still stands on the blockchain}, where processing and storage are especially costly.
Several schemes for compression are being studied, even on the \href{https://eips.ethereum.org/EIPS/eip-3772}{EVM level}.

These techniques could also be leveraged to harden contracts against reverse-engineering.
Both data and / or code can be packed, by the contract itself, a proxy or a web app.

Unpacking can be performed either by the contract itself or by a proxy.

\subsection{Evasion Targets}

\subsubsection{Block Explorers}

With the input data packed in the transaction history, making sense of past events is harder.

\subsubsection{Security Tools}

All the known patterns and signatures will fail on the packed data.

\subsubsection{Security Reviewers}

Interacting with a packed contract may require additional layers of (un)packing to handle the input and outputs.
If the (byte)code is packed, static analysis will be significantly slowed too.

\subsection{Samples}

To our knowledge, this technique is a speculation and has not yet been witnessed in Web3.

\subsection{Detection \& Countermeasures}

\subsubsection{Entropy}

Usually, these obfuscation schemes can be detected by measuring the entropy.
This is harder to implement in this context because the blockchain makes extensive use of hashing algorithms, which are high entropy.
