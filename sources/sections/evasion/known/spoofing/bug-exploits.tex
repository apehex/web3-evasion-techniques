\section{Bug Exploits}

\subsection{Overview}

A more vicious way to mask ill-intented code is to exploit bugs and EVM quirks.
By definition, these bugs trigger unwanted / unexpected behaviors.

They can be:

\begin{itemize}
\item{EVM quirks: in particular, some operations are implied and not explicitely written}
\item{bugs: the Solidity language itself has \href{https://github.com/ethereum/solidity/blob/develop/docs/bugs.json}{numerous bugs}, depending on the version used at compilation time \cite{changelog-solidity-bugs}}
\end{itemize}

They are usually leveraged in honeypots, where the attackers create a contract that looks vulnerable.
But the "vulnerability" doesn't work and people who try to take advantage of it will lose their funds.

\subsection{Evasion Targets}

\subsubsection{Security Tools}

Honeypots are meants to trigger alerts in popular tools to make their users think they found a vulnerable contract.

\subsubsection{Reviewers}

Successfully used in honeypots, these tricks can fool security professional.

\subsection{Samples}

All the samples below come from the paper \href{https://arxiv.org/pdf/1902.06976.pdf}{The Art of The Scam: Demystifying Honeypots in Ethereum Smart Contracts} \cite{paper-art-of-the-scam}.

\subsubsection{Impossible Conditions}

Attackers can craft a statement that will never be true.

A \href{https://www.youtube.com/watch?v=4bSQWoy5a_k}{minimal example} was given at DEFI summit 2023 by Noah Jelic \cite{video-hacker-traps}:

\begin{lstlisting}[language=Solidity]
function multiplicate() payable external {
    if(msg.value>=this.balance) {
        address(msg.sender).transfer(this.balance+msg.value);
    }
}
\end{lstlisting}

This gives the illusion that anyone may-be able to withdraw the contract's balance.

However, at the moment of the check, \lstinline[language=Solidity]{this.balance} has already been incremented: it can never be lower than \lstinline[language=Solidity]{msg.value}.

In reality, the contract would have exactly the same behavior if the \lstinline{multiplicate} function was empty.

\subsubsection{Skip Empty String Literal}

The Solidity encoder skips empty strings: the following arguments in a function call are shifted left by 32 bytes.

In the following snippet, the call to \lstinline[language=Solidity]{this.loggedTransfer} ignores \lstinline[language=Solidity]{msg.sender} and replaces it with \lstinline[language=Solidity]{owner}.
In other words the sender cannot actually receives the funds, it is a bait.

\begin{lstlisting}[language=Solidity]
function divest ( uint amount ) public {
    if (investors[msg.sender].investment == 0 || amount == 0) throw;
    investors[msg.sender].investment -= amount;
    this.loggedTransfer(amount, "", msg.sender, owner);
}
\end{lstlisting}

\subsubsection{Type Deduction Overflow}

The compiler uses type deduction to infer the the smallest possible type from its assignment. For example, the counter is given the type \lstinline[language=Solidity]{uint8}, and the loop actually finishes at 255 instead of \lstinline[language=Solidity]{2*msg.value}:

\begin{lstlisting}[language=Solidity]
if (msg.value > 0.1 ether) {
    uint256 multi = 0;
    uint256 amountToTransfer = 0;
    for (var i=0; i < 2*msg.value; i++) {
        multi = i * 2;
        if ( multi < amountToTransfer ) {
            break;
        }
        amountToTransfer = multi;
    }
    msg.sender.transfer(amountToTransfer);
}
\end{lstlisting}

Since the caller must have sent \lstinline[language=Solidity]{0.1 ether} he loses money.

\subsubsection{Uninitialised Struct}

Non initialized structs are mapped to the storage. In the following example, the struct \lstinline[language=Solidity]{GuessHistory} overwrites the "private" random number.

\begin{lstlisting}[language=Solidity]
contract GuessNumber {
    uint private randomNumber = uint256(keccak256(now)) % 10+1;
    uint public lastPlayed;
    struct GuessHistory {
        address player;
        uint256 number;
    }
    function guessNumber (uint256 _number) payable {
        require (msg.value >= 0.1 ether && _number <= 10);
        GuessHistory guessHistory;
        guessHistory.player = msg.sender;
        guessHistory.number = _number ;
        if (number == randomNumber)
            msg.sender.transfer(this.balance);
        lastPlayed = now;
    }
}
\end{lstlisting}

in the check \lstinline[language=Solidity]{(number == randomNumber)}, the \lstinline[language=Solidity]{randomNumber} is now an address which is highly unlikely to be lower than 10.

\subsection{Detection \& Countermeasures}

\begin{itemize}
\item{testing: symbolic testing \& fuzzing will show the actual behavior; the issue is rather to formulate what is expected for any arbitrary contract}
\item{CVEs: known vulnerabilities can be identified with pattern matching; in traditional malware detection, \href{https://yara.readthedocs.io/en/stable/writingrules.html}{YARA rules} are written}
\end{itemize}

There's a tool aimed specifically at detecting honeypots, \href{https://github.com/christoftorres/HoneyBadger}{HoneyBadger}.
